*******************************************************************************************
64K x 8bit的Flash
20K x 8bit的SRAM
37个GPIO，分别为PA0-PA15、PB0-PB15、PC13-PC15、PD0-PD1
2个12bit ADC合计12路通道，外部通道：PA0到PA7以及PB0到PB1。
内部通道：温度传感器通道ADC_Channel_16和内部参考电压通道ADC_Channel_17
4个16bit定时器/计数器，分别为TIM1、TIM2、TIM3、TIM4
2个看门狗定时器（独立看门狗IWDG、窗口看门狗WWDG）
1个24bit向下计数的滴答定时器systick
2个IIC，2个SPI，3个USART，1个CAN

*******************************************************************************************
GPIO被设置为输入模式，是不需要设置GPIO端口的最大输出速度

GPIO_ReadInputDataBit() 读取输入数据

STM32的所有GPIO都可以用作外部中断源的输入端，利用这个特性，我们可以把按键轮询检测 改为由中断 来处理，大大提高软件执行的效率。

目前（2014-7-13）只能使用串口一


2016-1-9修改日志：

1、修改了mpu6050代码 加入了IO模拟IIC时序读取函数 可能部分使用硬件IIC调用的宏定义没有正确的修改需要注意 IO模拟的IIＣ读取方式是通过了测试的
2、加入了BMP180 HMC5883 虚拟示波器 四元数等代码
3、更新了卡尔曼滤波底层代码
 
*******************************************************************************************
GPIO寄存器描述 《STM32参考手册中文-p75》

1、端口配置低寄存器(GPIOx_CRL)(x = A...E)
2、端口配置高寄存器(GPIOx_CRH)(x = A...E)

3、端口输入数据寄存器(GPIOx_IDR)(x = A...E)
   这些位为只读并只能以字(16位)的形式读出。读出的值为对应I/O口的状态。
   
4、端口输出数据寄存器(GPIOx_ODR)(x = A...E)
   只能以字(16bit)的形式操作，复位值全是0。写0即输出0，写1即输出1。
   
5、端口位设置/清除寄存器(GPIOx_BSRR)(x = A...E)
   高16bit写1用于清0，低16bit写1用于置位，同时写1的话低16bi有效。
   
6、端口位清除寄存器(GPIOx_BRR)(x = A...E)
   低16位写1用于置位。
   
7、端口配置锁定寄存器(GPIOx_LCKR)(x = A...E)

GPIO八种模式
typedef enum
{ GPIO_Mode_AIN = 0x0,            /* 模拟输入 */   
  GPIO_Mode_IN_FLOATING = 0x04,   /* 浮空输入，复位后的状态 */
  GPIO_Mode_IPD = 0x28,           /* 下拉输入 */
  GPIO_Mode_IPU = 0x48,           /* 上拉输入 */
  GPIO_Mode_Out_OD = 0x14,        /* 开漏输出 */
  GPIO_Mode_Out_PP = 0x10,        /* 推挽输出 */
  GPIO_Mode_AF_OD = 0x1C,         /* 复用开漏输出 */
  GPIO_Mode_AF_PP = 0x18          /* 复用推挽输出 */
}GPIOMode_TypeDef;



/*************************************************************************
*  作者 :CCRP
*  函数名称: 
*  功能说明: 
*  参数说明:   
*  函数返回: 
*  修改时间:      
*  备    注: 
*************************************************************************/